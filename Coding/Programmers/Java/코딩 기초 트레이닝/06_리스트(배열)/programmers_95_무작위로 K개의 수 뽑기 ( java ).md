# [ Programmers ] 무작위로 K개의 수 뽑기 ( java ) 95 / 124
https://school.programmers.co.kr/learn/courses/30/lessons/181858

## 문제 설명

랜덤으로 서로 다른 k개의 수를 저장한 배열을 만드려고 합니다. 적절한 방법이 떠오르지 않기 때문에 일정한 범위 내에서 무작위로 수를 뽑은 후, 지금까지 나온적이 없는 수이면 배열 맨 뒤에 추가하는 방식으로 만들기로 합니다.

이미 어떤 수가 무작위로 주어질지 알고 있다고 가정하고, 실제 만들어질 길이 `k`의 배열을 예상해봅시다.

정수 배열 `arr`가 주어집니다. 문제에서의 무작위의 수는 `arr`에 저장된 순서대로 주어질 예정이라고 했을 때, 완성될 배열을 return 하는 solution 함수를 완성해 주세요.

단, 완성될 배열의 길이가 `k`보다 작으면 나머지 값을 전부 -1로 채워서 return 합니다.


### 제한사항

- 1 ≤ `arr`의 길이 ≤ 100,000
    - 0 ≤ `arr`의 원소 ≤ 100,000
- 1 ≤ `k` ≤ 1,000


### 입출력 예

|arr|k|result|
|---|---|---|
|[0, 1, 1, 2, 2, 3]|3|[0, 1, 2]|
|[0, 1, 1, 1, 1]|4|[0, 1, -1, -1]|


### 입출력 예 설명

입출력 예 #1

- 앞에서부터 서로 다른 `k`개의 수를 골라내면 [0, 1, 2]가 됩니다. 따라서 [0, 1, 2]를 return 합니다.

입출력 예 #2

- 서로 다른 수의 개수가 2개 뿐이므로 서로 다른 수들을 앞에서부터 차례대로 저장한 [0, 1]에서 이후 2개의 인덱스를 -1로 채워넣은 [0, 1, -1, -1]을 return 합니다.

## 문제 풀이
### 코드 설명
- 코드의 목적:
    
    - 주어진 정수 배열(arr)과 정수(k)를 입력으로 받아, 배열에서 중복 원소를 제거하고, 처음부터 k개의 원소를 새로운 배열에 넣습니다. 만약 k가 중복을 제거한 배열의 길이보다 크다면, 나머지 자리는 -1로 채웁니다.
- 코드의 주요 구조:
    
    - Solution 클래스와 solution 메소드로 구성
    - solution 메소드에서는 ArrayList를 사용하여 중복을 제거한 정수들을 저장하고, 이를 정수 배열로 변환합니다.
- 코드의 주요 알고리즘:
    
    - ArrayList와 for-each loop를 사용하여 주어진 배열의 각 원소를 중복 없이 리스트에 추가합니다.
    - for loop를 사용하여 리스트의 첫 k개 원소를 새로운 배열에 넣습니다. k가 리스트의 길이보다 크다면 나머지 자리는 -1로 채웁니다.
- 코드의 핵심:
    
    - 주어진 배열의 각 원소를 중복 없이 리스트에 추가하고, 첫 k개 원소를 새로운 배열에 넣는 것
    - ArrayList를 효율적으로 사용하여 배열 처리를 수행하는 것

### 풀이
```
import java.util.ArrayList;

class Solution {

    // solution 메소드 정의, 주어진 정수 배열과 정수를 매개변수로 받음
    public int[] solution(int[] arr, int k) {
        
        // 중복을 제거한 정수를 저장할 ArrayList를 생성
        ArrayList<Integer> list = new ArrayList<>();

        // 주어진 배열의 각 원소를 중복 없이 리스트에 추가
        for (int n : arr) {
            if (!list.contains(n)) {
                list.add(n);
            }
        }
        
        // 첫 k개 원소를 저장할 새로운 배열을 생성
        int[] answer = new int[k];

        // 리스트의 첫 k개 원소를 새로운 배열에 넣음, k가 리스트의 길이보다 크면 나머지 자리는 -1로 채움
        for (int i = 0; i < k; i++) {
            
            if (i > list.size() -1) {
                answer[i] = -1;
                
            } else {
                answer[i] = list.get(i);
            }
        }

        // 새로운 배열을 반환
        return answer;
    }
}
```

